\chapter{Lean Proof Assistant}\label{s:lean}

In this section, I will go over the most relevant to the paper high-level Lean topics. The topics include type theory, inductive types and proof tactics. I will also compare them to Isabelle/HOL such that later proof comparisons would be more intuitive.

The Lean proof assistant is based on dependent type theory with inductive families.
%https://link.springer.com/article/10.1007/bf01211308 %

Simple type theory in Lean is used to associate every expression with a type. This means that there is no room for different interpretations. 
%https://leanprover.github.io/theorem_proving_in_lean/theorem_proving_in_lean.pdf
For example, each expression, a variable, a function or a constant, will have a type, for instance - an integer. What makes the Lean type theory powerful is that from the existing types we can build new ones. If $\alpha$ and $\beta$ are types, and $\alpha \rightarrow \beta$ is a function type out of them, there can also be a new type $\alpha \times \beta$.
%% Insert an example of that

Lean extends simple type theory by making treating the types themselves as objects. This means that types have to have a type which is the case - any type, even the basic such as \lstinline{nat} or \lstinline{bool}, have a type \lstinline{Type}.
%insert example from page 13
In proofs this allows us to operate on types the same way we operate on objects.

To define an object or a function of a certain type in Lean, \lstinline{def} is used to do that. Objects are used in proofs and proofs are also the ones that verify their correctness. The general form of a definition is as follows: $def foo : \alpha := bar$ (the type sometimes can be inferred, but the best practice is to specify it). 

Lean also has inductive types. Inductive types in Lean allow us to create types from scratch. A lot of definitions in Lean are made using inductive types, which allow us to use induction in the proofs or to define a recursive type. Inductive types are built from separate constructors, which are used to construct new objects of such type using previously defined values.
% (src: https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html). 
The inductive type creates abstraction over the constructors and makes it easier to reason about each object collectively. This also allows to have recursion in the types themselves where the input becomes the type itself. This is because each constructor acts like a definition of that type, therefore it can have a its type passed as an argument.
% insert example of list

\begin{lstlisting}
    inductive list (T : Type) : Type :=
    | nil {} : list T
    | cons   : T → list T → list T
\end{lstlisting}

In Isabelle/HOL types are used in a similar manner. They are defined using the datatype keyword and they are built already as inductive types with possible several constructors.

\todo{add more text about this/add and explain examples}

Next important part is proof tactics in Lean. The tactics are recognized by keywords \lstinline{begin ... end} and \lstinline{by}. The tactic proofs are backward reasoning proofs, meaning the goal is broken down into smaller sections which are proven separately and construct a full proof. The advantage of these proofs are that the goal can be very complex and by splitting it into smaller problems, it makes it possible to achieve the goal. There are the opposite proof strategy - structured proofs, which are used for forward reasoning, are proofs which begin with hypotheses and assumptions and work towards the goal. In practice, both of these strategies are used together to split the goal into smaller parts and use hypotheses to prove subgoals.

Tactics in Lean can be partially automated, which are usually helpful to use to avoid long and tedious proofs. Some of the most used automated tactics in my case are \lstinline{simp} (it applies several trivial rewriting steps (can be by using a given hypothesis) which simplify the goal), \lstinline{linarith} (combines existing (in)equalities to find a contradiction between them), \lstinline{ring_nf} (solves equations that are in a commutative (semi)ring structure), \lstinline{finish} (simplifies the goal, eliminates quatifiers and looks for contradiction), and \lstinline{exact} (applies the hypothesis which is the same as the goal). Since most of these tactics help prove trivial goals or complete a set of trivial operations, they do not interfere with the clarity of the proof.

In Isabelle/HOL there are more automated proofs. There is \emph{simp} which is similar to Lean's, but there is also \emph{auto}, which is able to prove simple logical or set-theoretic goals \cite{isabelle}. Some of the automated proofs that are used more frequently are \emph{fastforce}, which tries harder than auto, and it works on the first subgoal only where it either succeeds or fails, and blast which is commonly used to prove complex logical goals. The automated proofs are said to be complete if they can prove all true formulas, but there is no complete proof method for Isabelle, which is why there are different automated proof methods.
