\chapter{Related Work}\label{s:related}

In this section, I will cover similar formal verification systems to what I have covered in this paper. This includes verification in proof assistants such as Isabelle \cite{isabelle, webasm}, Coq \cite{coq_concrete_semantics, coq_c}, program verifiers Why3 \cite{why3} and Stainless \cite{stainless}.  

Automatic proof assistants include Isabelle and Coq, in which the proofs are automated to the extent that the user does not need to manually create full proof systems. One of the works comparing these theorem provers is by Czajka \emph{et al.} \cite{coq_concrete_semantics}. They compare the assistants by translating theorems and proofs from Isabelle to Coq from Concrete Semantics by Nipkow and Klein \cite{isabelle} like I do to Lean but do that with additional chapters, which in my case have already been covered in Hitchhiker's Guide by Baanen \emph{et al.} \cite{hithchiker}. Their goal is to improve the CoqHammer tool, which searches for Coq proofs while showing the similarities and differences to Isabelle. Similar to Isabelle's auto or other automated tactics, CoqHammer has the main tactic \emph{hammer}, which combines machine learning and automated reasoning techniques to accomplish goals automatically. It also provides \emph{sauto} which is a strong version of Coq tactic \emph{auto} to simplify the goal as much as possible and perform rewrites using existing hints from an importable database. Even though Coq has automation, Czajka \emph{et al.} \cite{coq_concrete_semantics} show that Isabelle does perform faster (on the same hardware) and has fewer lines of code and tactics used than Coq. 

I have shown a small toy-like example of formal verification, but there exist real-world examples of formally verified systems. One of the examples is C11 compiler formalization in Coq by Krebbers \cite{coq_c}. The compiler is formalized in normalized CH$_2$O semantics, which is an incomplete but sufficient representation of the compiler in Coq. The normalized semantics were created such that if there is proof for any given program with respect to them, the proof would hold for any existing C compiler that adheres to the standard. It also allows improvement in the future versions of the C compiler standard and addresses issues on indeterminate memory and pointers which is important in such language as C. Another example of a real-world application of this is WebAssembly mechanization and verification in Isabelle by Watt \cite{webasm}. The verification of this programming language allowed Watt to fix several errors in the official WebAssembly specification and create an executable verified interpreter that could be used instead of the official interpreter in the future.

In addition to proof assistants, there are program verifiers that create dedicated environments to verify the behavior of programs written in some specific programming language. They can help one to verify programs written in some imperative language, and these program verifiers have a high level of automation in proofs because the languages specified in them are less expensive then in proof assistants. One of the program verifiers Why3 is discussed by Clochard \emph{et al.} \cite{why3}. Why3 was also used to create an interpreter and prove the correctness of a simple programming language, and it is designed to be even more automatized and fast. Automatization is relevant when proving not a small compiler but a complex program. Another program verifier example is Stainless which is a Scala program verifier developed by the LARA group in EPFL presented by Voirol \cite{stainless}. To verify them Scala programs are translated into an intermediate verification language using an Inox interpreter and then programs can be verified with some automation in the system using Stainless.

