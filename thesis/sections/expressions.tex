\chapter{Expressions}\label{s:expressions}
I will define the compiler in three separate steps as it is done in the Concrete Semantics \cite{isabelle}, beginning with arithmetic expressions, then boolean expressions and then for commands. Proofs of the correctness of these expressions will follow in the next section.

\section{Arithmetic expressions}

Arithmetic expressions are similar to the instruction definitions because each expression corresponds to an instruction that is put in the list. In the defi
\begin{lstlisting}
def acomp : aexp → list instr
| (num n) := [LOADI n]
| (var x) := [LOAD x]
| (add e₁ e₂) := acomp e₁ ++ acomp e₂ ++ [ADD]
| (sub e₁ e₂) := acomp e₁ ++ acomp e₂ ++ [SUB]
| (mul e₁ e₂) := acomp e₁ ++ acomp e₂ ++ [MUL]
| (div e₁ e₂) := acomp e₁ ++ acomp e₂ ++ [DIV]
\end{lstlisting}

\section{Boolean expressions} \label{bexp}
Boolean expressions are a little bit trickier to define since it does not directly correspond to instructions. In this case boolean expressions compilation takes additional parameters compared to arithmetic, of which flag \lstinline{f} of type \lstinline{Prop} indicates what value of the boolean expression represents the true case, offset \lstinline{n} is used to specify how much does the program counter needs to be shifted by. 
\begin{lstlisting}
noncomputable def bcomp : bexp → Prop → ℤ → list instr 
| (Bc v) f n := if (v = f) then [JMP n] else []
| (Not b) f n :=  bcomp b (¬ f) n
| (And b1 b2) f n := 
    let cb2 := bcomp b2 f n,
      m := if (f = true) then int.of_nat (list.length cb2) else int.of_nat (list.length cb2) + n,
      cb1 := bcomp b1 false m
    in cb1 ++ cb2
| (Less a1 a2) f n := acomp a1 ++ acomp a2 ++ 
  (if (f = true) then [JMPLESS n] else [JMPGE n])
\end{lstlisting}

\lstinline{Bc} or boolean constant case is simple - if the constant is equal to the flag, then create a jump, otherwise nothing is returned. The \lstinline{Not} case is self-explanatory - it changes the flag to be the opposite, such that during the compilation it compares the negated case. \lstinline{Less} is creating either \lstinline{JMPLESS} or \lstinline{JUMPGE} instruction depending on the flag \lstinline{f}. The \lstinline{And} expression compilation builds a list of instructions, where if the first compilation is true, the second is executed, otherwise after the first compilation jump is set to be over the second and by n. There is no way to make these compilations parallel, so they have to be executed sequentially, which makes the definition of the expression complicated.  

When defining \lstinline{bcomp} cases I use \lstinline{noncomputable} flag, because I generate data that is asserting its existence by using \lstinline{let} to define variables in \lstinline{And} case. This is described in Theorem Proving in Lean \cite{theorem_proving_in_lean}.

\section{Commands}

The main idea of compiled commands is a program that will perform the same state transformation and end with a program counter at the \lstinline{(ccomp c).length}. During that transformation, commands can take multiple intermediate state steps or have intermediate stack values but in the end, will result in a compiled program.  

\begin{lstlisting}
noncomputable def ccomp : com → list instr
| com.SKIP := []
| (Assign x a) := acomp a ++ [STORE x]
| (Seq c1 c2) := ccomp c1 ++ ccomp c2
| (If b c1 c2) := (
  let cc1 := ccomp c1,
    cc2 := ccomp c2,
    cb := bcomp b false (list.length cc1 + 1)
  in cb ++ cc1 ++ (JMP (list.length cc2) :: cc2)
)
| (While b c) := (
  let cc := ccomp c,
    cb := bcomp b false (list.length cc + 1)
  in cb ++ cc ++ [JMP (-(list.length cb + list.length cc + 1))] 
)
\end{lstlisting}

The commands mostly are trivial except the ones that have branches - \lstinline{If} and \lstinline{While}. \lstinline{If} compiles to the instruction list, where if the boolean expression is true, \lstinline{cc1} (\emph{THEN} branch) follows the condition without jumps and afterward jumps over \lstinline{cc2}. Otherwise, \lstinline{cc2} (\emph{ELSE} branch) is executed by jumping from condition over the \lstinline{cc1} branch and the \lstinline{JMP} instruction. \lstinline{While} command is in a similar manner as \lstinline{If}, just in this case, instead of \emph{THEN} branch there is either exiting the loop if the condition is false, or jumping back to the condition after the while body.

The command compilation also uses the \lstinline{noncomputable} flag because of the same reason as \lstinline{bcomp} - using \lstinline{let} in the definition.


